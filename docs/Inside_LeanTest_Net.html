

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Inside_LeanTest_Net - LeanTest</title>

	<link rel="icon" type="image/x-icon" href="images/favicon.ico">
    <link rel="stylesheet" href="bootstrap/css/readable/bootstrap.min.css" />
<link rel="stylesheet" href="font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="sidebar/sidebar.min.css" />
<link rel="stylesheet" href="css/book.min.css" />
<link rel="stylesheet" href="syntax-highlight/solarized-light.min.css" />
<link rel="stylesheet" href="mermaid/mermaid.css" />

</head>

<body>
    
    <nav class="navbar navbar-inverse navbar-fixed-top">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="#sidebar-toggle" id="sidebar-toggle">
					<i id="sidebar-toggle-icon" class="hidden-md hidden-lg hidden-xl fa fa-angle-double-right" aria-hidden="true"></i>
					LeanTest
				</a>
            </div>
            <div id="navbar" class="navbar-collapse collapse">
                <ul class="nav navbar-nav">
                    <li><a href="index.html"><i class="fa fa-home" aria-hidden="true"></i> Home</a></li>
					<li><a href="https://github.com/SaxoBank/Leantest"><i class="fa fa-github" aria-hidden="true"></i> GitHub Repository</a></li>
                    <li><a href="https://www.nuget.org/packages?q=leantest"><i class="fa fa-download" aria-hidden="true"></i> Download</a></li>
                    <li><a href="LicenseApache.html">License</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container">
        <div class="row">
            <div id="sidebar" class="col-md-3 hidden-sm hidden-xs">
                
        <div class="panel panel-default">
            <div class="panel-heading">
                <h4>On This Page</h4>
            </div>
            <div id="header-menu" class="panel-body main-menu">
                <ul></ul>
            </div>
        </div>  
        <div class="panel panel-default">
            <div class="panel-heading">
                <h4>Table of Contents</h4>
            </div>
            <div class="panel-body main-menu">
                <ul>
	<li><a href="index.html">Home</a></li>
	<ul>
	</ul>
	<li><a href="Introduction.html">Introduction</a></li>
	<ul>
	</ul>
	<li><a href="Inside_LeanTest_Net.html" class="selected">Inside LeanTest.Net</a></li>
	<ul>
	</ul>
	<li><a href="LicenseApache.html">License</a></li>
	<ul>
	</ul>
	<li><a href="README.html">Readme</a></li>
	<ul>
	</ul>
</ul>
            </div>
        </div>

            </div>
			<div id="contentarea" class="col-md-9 col-sm-12 col-sm-push-0 col-xs-12 col-xs-push-0">
				<ul class="pager">
	<li class="previous"><a href="Introduction.html">Previous: Introduction</a></li>
	<li class="next"><a href="LicenseApache.html">Next: License</a></li>
</ul>
				<div id="static-content" class="markdown">
					<h1 id="inside-leantest.net">Inside LeanTest.Net</h1>
<p>The Lean Testing methodology is backed up by a simple library, a set of nuGet packages named <a href="https://github.com/SaxoBank/Leantest">LeanTest.Net</a>.</p>
<p>LeanTest.Net is little more than an implementation of a Builder pattern. In fact, the functionality of LeanTest.Net is so simple that it could almost serve as a morning coding kata for an experienced developer.</p>
<p>While it is sufficient to understand that a test which,</p>
<ul>
<li>calls <em>WithData</em> on a context builder <em>declares</em> data, and when the test then</li>
<li>calls Build it <em>passes</em> that data to the test target</li>
</ul>
<p>it can still be useful to understand what goes on under the hood, as it makes it more obvious how to write simple and elegant tests, and also to reason about what functionality existing tests cover.</p>
<p>This text is aimed at those who want to understand what is going on inside LeanTest.Net.</p>
<h2 id="the-builder-pattern">The Builder Pattern</h2>
<p>Let's assume that we want to write tests against a piece of software which has an external dependency represented by the interface IMyExternalService.</p>
<p>With Lean Testing, we mock as little as possible and when we do mock, we always mock at the boundary of external dependencies. We write tests in terms of the relevant state of such external dependencies.</p>
<p>Thus, in this case, it makes sense to have a mock implement IMyExternalService, then pass relevant state to it in each test.</p>
<p>In essence, all that our Builder pattern does is to pass data from a test to a mock via an internal <em>context data store,</em></p>
<table>
<thead>
<tr>
<th>Test <em>arrange</em> part</th>
<th>Context data store</th>
<th>Mock (the <em>receiver</em>)</th>
</tr>
</thead>
<tbody>
<tr>
<td>_contextBuilder<br>.WithData(new<br><strong>My</strong>())<br>.Build();</td>
<td><strong>My</strong>: &lt;one instance&gt;</td>
<td>internal class MockForDataMy : IMockForData&lt;<strong>My</strong>&gt;, IMyExternalService<br>{<br>public voidWithData(<strong>My</strong> data) { }<br>public void Build(Type type) {}<br>// ...<br>}</td>
</tr>
</tbody>
</table>
<p>It is core to Lean testing that we pass data between a test and a mock this way.</p>
<p>We do not simply instantiate an instance of a mock and feed it with context data, as that would tightly couple tests with mocks. By avoiding such a tight coupling, we can write tests which emphasize <em>what</em> is being tested, rather than <em>how</em> it is being tested. This not only means that test code is not coupled to a specific mock implementation, it also means that the test code does not depend on a mock being implemented at all. The test in the example above declares that it depends on having a My data in the context, but the test does not care whether the data is passed to a mock or a database.</p>
<p><em>Declaring</em> data needed for a test, without explicitly stating <em>how</em> that data is supposed to be used, is what allows us to write tests in one consistent way, with any kind of mocking strategy, running in-process or out-of-process, mocking a database or not, running with immediate external dependencies or a full environment.</p>
<p>In short, there is one consistent way to write tests at any level and there is one consistent way to reason about functional test coverage.</p>
<p>Note that the test uses the <em>type</em> of the instance of data passed to the mock in order to decide the receiver, i.e. in order to identify the mock which will receive the data. We expect representations of external dependencies to use strong typing.</p>
<p>Also note how a mock declares what type of data it is prepared to receive simply by implementing the interface IMockForData&lt;&gt;. Build() on the context builder will pass data of type <em>T</em> from the internal data store by <em>asking the DI container</em> for implementations of IMockForData&lt;T&gt;. LeanTest.Net will never use reflection to discover receivers of data, <em><strong>it will rely on receivers to be registered with the DI container and tests to declare relevant data</strong></em>.</p>
<h3 id="multiple-receivers">Multiple Receivers</h3>
<p>In the example above we had a piece of data which was passed to a single mock. It is not always that simple; in fact, <em><strong>the possibility of having multiple receivers with a consistent view of test data is one major benefit of our flavour of the Builder pattern</strong></em>.</p>
<p>One example usage of multiple receivers could be a test which declares that the financial Forex instrument EURUSD must be known and available. The external dependencies could be a number of backend services which each is responsible for handling a single aspect of that instrument (such as pricing, margin calculations etc.). We would expect that if one of these know about EURUSD, then the others will also.</p>
<p>Another example is when <em>time itself</em> is an external dependency. If the code under test has logic around the current time and also run code regularly on a thread as spun up by a timer, then you would expect such code to have the same notion of time. In other words, if a test declares that the current time is <em>Star Wars day 2020</em>, then you expect that both the current time and the timer logic would reflect that.</p>
<p>Treating time as an external dependency is a coding pattern which is documented TODO, the example functionality being a write-cache which flushes at regular times. From the details of the documented code pattern it follows that a single DateTime instance declared in a test will be passed to the two
relevant mocks,</p>
<table>
<thead>
<tr>
<th>Test arrange part</th>
<th>Context data store</th>
<th>Mock</th>
</tr>
</thead>
<tbody>
<tr>
<td>_contextBuilder<br>.WithData(new <strong>DateTime</strong>(2020, 5, 4))<br>.Build();</td>
<td><strong>DateTime</strong>: &lt;one instance&gt;</td>
<td>internal class MockForDataDateTime : IDateTime, IMockForData&lt;<strong>DateTime</strong>&gt;<br>{<br>public void WithData(<strong>DateTime</strong> data) { }<br>public void Build(Type type) { }<br>// ...<br>}<br><br>internal class MockForDataTimer : ITimer<br>{<br/>public void WithData(<strong>DateTime</strong> data) { }<br>public void Build(Type type) { }<br>// ...<br/>}<br/></td>
</tr>
</tbody>
</table>
<h3 id="multiple-builders">Multiple Builders</h3>
<p>In the examples above we passed data to mocks. It is not always that simple; actually, <em><strong>not hardcoding that data is passed to any given mock is one major benefit of our flavour of the Builder pattern</strong></em>.</p>
<p>LeanTest.Net's Builder pattern supports multiple builders. At the time of writing, a <em>mock-for-data builder</em> and a <em>state handler builder</em> are provided out-of-the-box.</p>
<p>The difference between these two builders is only conceptual. In
short,</p>
<ul>
<li>The <em>mock-for-data builder</em> passes data to mock implementations. Mock implementations <em>substitute production code</em> by implementing one or more interfaces, such as IMyExternalDependency, along with IMockForData&lt;T&gt; for all relevant data types T.</li>
<li>The <em>state handler builder</em> passes data to state handler implementations. State handler implementations manage state of direct external dependencies by implementing  IStateHandler&lt;T&gt; for all relevant data types T. A state handler will never substitute production code.</li>
</ul>
<p>Since mocks substitute production code, we will mock as little as possible, thereby putting as much code under test as possible. And when we mock, we will try to not mock away any production code which is relevant to put under test. Key to this is to define façade interfaces TODO: link representing external dependencies; these interfaces are defined such that a production code implementation contains no logic, only pass-through to the actual external dependency.</p>
<p>State handlers are typically used to handle data in database(s), but can also be used to handle other state, such as data in a distributed cache or a file system. In either case, a state handler must take full responsibility for handling the data. For a SQL database, that would involve deleting/inserting data in a way which respects referential integrity. Naturally, such destructive behaviour assumes ownership of the database.</p>
<p>A special use of state handlers is for shared environments, in which destructive actions are not come-il-faut. The best we can do in such an environment is to be explicit about our assumptions, checking and ensuring whenever possible. Tests may still fail for all the reasons which tests fail in shared environments, but at least we can more easily determine the assumption(s) that fail and do corrective actions immediately.</p>
<p>Naturally, the principle of having multiple receivers applies across multiple builders. Returning to an earlier example, a test could declare that EURUSD must be known and available; this instrument can then be passed to an INCA mock implementation as well as to a table in the test target's own database.</p>
<h2 id="the-data-life-cycle">The Data Life-Cycle</h2>
<p>In the examples above, we have declared data in tests using WithData, then sent data to mocks and state handlers, via the context store and the builders.</p>
<p>There is obviously a connection between WithData/Build in a test, and WithData/Build in mocks and state handlers, and it is quite possible
to write tests without understanding the finer details of that connection.</p>
<p>However, for those who want to dig a bit deeper in order to excel at writing tests, here are the finer details.</p>
<p>The interfaces for mocks and state handlers, IMockForData&lt;T&gt; and IStateHandler&lt;T&gt; implement PreBuild and PostBuild in addition to WithData and Build,</p>
<pre><code class="language-{.syntaxhighlighter-pre">/// &lt;summary&gt;Declare data of type &lt;c&gt;T&lt;/c&gt;.&lt;/summary&gt;
void WithData(T data);
/// &lt;summary&gt;Called before build only once for the instance, allows you to prepare to populate state.&lt;/summary&gt;
void PreBuild();
/// &lt;summary&gt;Use the declared data to populate state, called after all data of type &lt;c&gt;type&lt;/c&gt; has been put to the instance with &lt;c&gt;WithData&lt;/c&gt;.&lt;/summary&gt;
void Build(Type type);
/// &lt;summary&gt;Called after build, only once for the instance.&lt;/summary&gt;
void PostBuild();
</code></pre>
<p>We implement either IMockForData&lt;T&gt; or IStateHandler&lt;T&gt;, but not both in a single class.</p>
<p>It is often a good idea to implement either of the interfaces for several types T<sub>1</sub>, T<sub>2</sub>, ... T<sub>n</sub> in a single class[. For example, a state handler which handles data in a SQL database, will be able to insert and delete records corresponding to T<sub>1</sub>, T<sub>2</sub>, ... T<sub>n</sub> with respect to equivalent relational constraints in the database.</p>
<p>In general, the data life-cycle is,</p>
<ul>
<li>Calling WithData in a test will add data to the internal context data store; no data is passed to any mock or state handler.</li>
<li>Calling Build in a test will initiate a sequence of calls which will pass the data in the internal context data store to relevant mocks and state handlers. For each instance which implements either IMockForData&lt;T<sub>1</sub>&gt;, IMockForData&lt;T<sub>2</sub>&gt;, ... , IMockForData&lt;T<sub>n</sub>&gt; or IStateHandler&lt;T<sub>1</sub>&gt;, StateHandler&lt;T<sub>2</sub>&gt;, IStateHandler&lt;T<sub>n</sub>&gt;,
<ul>
<li>PreBuild is called once, allowing you to prepare to use the data which is coming. This allows you to delete any T<sub>1</sub>, T<sub>2</sub>, ... T<sub>n</sub> data stored in the instance, so that it is entirely clean. A state handler which handles data in a SQL database will delete all records, a mock will clear any internal data structures.</li>
<li>WithData is called once per piece of data in the internal context data store, for each type T<sub>1</sub>, T<sub>2</sub>, ... T<sub>n</sub> of data. This is where you would store the data in your own internal data structures in the mock or state handler.</li>
<li>Build is called once per type T<sub>1</sub>, T<sub>2</sub>, ... T<sub>n</sub> of data in the internal context data store. This is where you would commit
the data from the WithData phase if you need to do that per data type. If on the other hand, you do not need per-data type processing, or perhaps you require cross-data type processing, then you will do your processing in PostBuild instead.</li>
<li>PostBuild is called once, allowing you to clean-up. This is where you would do cross-data type work, such as storing data in
a relational database, assuming that there are relational constraints. This is also where you would dispose resources needed during the earlier phases.</li>
</ul>
</li>
</ul>
<p>Note that the above text describes the full flexibility of the data life-cycle, whereas most mock and state handler implementations will be much simpler.</p>
<p>Most implementations will simply receive one or more pieces of data which are returned by methods of a mocked interface. In such cases, PreBuild will be a no-op, WithData is a single line (an assignment), and both Build and PostBuild are no-ops. Here is the full implementation of the time mock mentioned above (and described in details TODO: link)</p>
<ul>
<li>WithData stores a DateTime instance and the two methods of the IDateTime mocked interface are implemented simply by returning that instance or calling Ticks on it respectively,</li>
</ul>
<pre><code class="language-{.syntaxhighlighter-pre">public class MockForDataDateTime : IDateTime, IMockForData&lt;DateTime&gt;
{
    public DateTime UtcNow { get; private set; } = DateTime.UtcNow;
    public long Ticks =&gt; UtcNow.Ticks;

    public void WithData(DateTime data) =&gt; UtcNow = data;

    public void PreBuild() {}
    public void Build(Type type) {}
    public void PostBuild() {}
}
</code></pre>
<h2 id="multiple-build-calls">Multiple Build Calls</h2>
<p>Most tests call WithData multiple times, then call Build once on a context builder. [This is because most test cases are simple enough that a single call to Build is sufficient.</p>
<p>But the entire data life-cycle is traversed every time a test calls Build and this allows us to handle more advanced test cases.</p>
<p>Some examples of advanced cases involve testing of time based functionality. Such tests will typically not be simple AAA tests, with a single <em>arrange</em>, a single <em>act</em> and a single <em>assert</em>. Rather, it is common to set the state of the test target, perhaps do a bit of acting, change the current time, act a bit more etc.</p>
<p>Again, we can use our write-cache TODO: link as an example. We arrange data, <em>act</em> in a way that puts data in the cache, <em>assert</em> that the cache has not been flushed (as no time has passed yet), then <em>arrange</em> that time passes past the flush delay, then finally <em>assert</em> that the cache has flushed as expected.</p>
<p>Here is the test using the extended AAA,</p>
<pre><code class="language-{.syntaxhighlighter-pre">[TestMethod]
public void PutMustUpdateWhenTimeBetweenCacheFlushesHasElapsed()
{
    DateTime startDateTime = DateTime.UtcNow;
    _contextBuilder
        .WithData&lt;UserSettingsRow&gt;(TestData.UserSettingsRows.User1InitialSettings)
        .WithData(startDateTime)
        .Build();
    string pre = _reader.Query(new UserSettingsQuery { UserId = 1, AppId = 42, Path = &quot;text&quot; });

    _target.PutUserSettings(new JValue(&quot;New value.&quot;), &quot;text&quot;);

    string afterPutButBeforeExpiry = _reader.Query(new UserSettingsQuery { UserId = 1, AppId = 42, Path = &quot;text&quot; });

    _contextBuilder.WithClearDataStore()
        .WithData(startDateTime + TimeSpan.FromMilliseconds(UserSettingsWriteCache.DefaultMillisecondsBetweenCacheFlushes + 1))
        .Build();

    string actual = _reader.Query(new UserSettingsQuery {UserId = 1, AppId = 42, Path = &quot;text&quot; });
    MultiAssert.Aggregate(
        () =&gt; Assert.AreEqual(@&quot;&quot;&quot;This is a string.&quot;&quot;&quot;, pre),
        () =&gt; Assert.AreEqual(@&quot;&quot;&quot;This is a string.&quot;&quot;&quot;, afterPutButBeforeExpiry),
        () =&gt; Assert.AreEqual(@&quot;&quot;&quot;New value.&quot;&quot;&quot;, actual));
}
</code></pre>
<p>Note that with the magic of MultiAssert we put all assert statements at the end of the test.</p>
<p>Also note the use of WithClearDataStore, which clears all data which was passed in WithData statements in the first arrange block. The effect of this is that only data from the following WithData statement will be passed in the data life-cycle, so the UserSettingsRow above will not be passed again. In other words, WithData in mocks and statehandlers will not be called again for the type UserSettingsRow. [However, PreBuild and PostBuild will still be called, since the data types are known to LeanTest-Net.</p>
<p>This is important to bear in mind when using multiple build calls, as it might influence the details of how mocks and state handlers must be implemented.</p>
<h2 id="dependency-injection-ioc-container-integration">Dependency Injection - IoC Container Integration</h2>
<p>LeanTest.Net only knows about mocks and state handlers that you explicitly expose to it. This is the only way; LeanTest.Net will never magically find mocks and state handlers using reflection. This is what we call the <em>no magic</em> principle.</p>
<p>You expose your preferred IoC container by implementing a simple interface (as described TODO: link,</p>
<pre><code class="language-{.syntaxhighlighter-pre">public interface IIocContainer
{
    T Resolve&lt;T&gt;() where T : class;
    T TryResolve&lt;T&gt;() where T : class;
    IEnumerable&lt;T&gt; TryResolveAll&lt;T&gt;() where T : class;
}
</code></pre>
<p>Your implementation is passed to LeanTest.Net initialization <em>once per test suite</em> as described TODO: link. Note that it is wrapped in a factory which ensures that a new IoC container instance, along with new mock and state handler instances, are created <em>before each test is run</em>.</p>
<p>The consequence of this is that <em><strong>each test will start with an empty context data store, empty (i.e., no data passed yet) mocks and state
handlers</strong></em>.</p>
<p>It also means that the builders for mocks and state handlers are <em>empty</em> in the sense that they do not know of any types for which to call PreBuild/Build/PostBuild on mocks and state handlers yet.</p>
<p>This is a consequence of our <em>no magic</em> principle, which is exactly what is needed in most cases.</p>
<h2 id="tweaking-the-data-life-cycle">Tweaking the Data Life-Cycle</h2>
<p>At rare occasions you may wish to have slightly more low-level control of the steps in the data life-cycle for certain data types.</p>
<p>We have already mentioned WithClearDataStore, which you use when you want to avoid passing data again to mocks and state handlers in subsequent calls to Build. This way, you control how WithData and Build is called on mocks and state handlers.</p>
<p>The data life-cycle also controls when PreBuild and PostBuild are called; in short, these will be called on instances which handle a type for which data has been declared. For example, if data for the type T<sub>1</sub> has been declared, then PreBuild and PostBuild will be called on implementations of IMockForData&lt;T<sub>1</sub>&gt; and IStateHandler&lt;T<sub>1</sub>&gt;. However, if you don't have data for T<sub>2</sub> in a given test, but still want PreBuild and PostBuild to be called on implementations of IMockForData&lt;T<sub>2</sub>&gt; and IStateHandler&lt;T<sub>2</sub>&gt;, then you simply declare empty T<sub>2</sub> data,</p>
<pre><code class="language-{.syntaxhighlighter-pre">_contextBuilder
    .WithData&lt;T2&gt;()
// ... 
</code></pre>
<p><strong>Experimental, not implemented yet</strong>: With the example above in mind, you may wish to go the opposite way; you may want the builders to forget about the type T<sub>1</sub>, effectively stopping them from calling PreBuild and PostBuild on implementations of IMockForData&lt;T<sub>1</sub>&gt; and IStateHandler&lt;T<sub>1</sub>&gt;. For this you use WithClearBuilders.</p>
<pre><code class="language-{.syntaxhighlighter-pre">_contextBuilder
    .WithClearBuilders()
// ... 
</code></pre>
<p>Note that WithClearBuilders imply WithClearDataStore. Also note that WithClearBuilders and WithClearDataStore are never needed until the second call to Build on the context builder, as a test will always start with a clear data store and clear builders.</p>

				</div>
				<ul class="pager">
	<li class="previous"><a href="Introduction.html">Previous: Introduction</a></li>
	<li class="next"><a href="LicenseApache.html">Next: License</a></li>
</ul>
			</div>
        </div>
    </div>
    
    <footer class="panel-footer text-center">
        <div align="center">Copyright © 2017-2021 Brian Elgaard Bennett</div>
		<div align="right">
			<small>
				Documentation created with <a href="https://johtela.github.io/LiterateCS/">LiterateCS</a>.
			</small>
		</div>
    </footer>


    
    <script src="bootstrap/js/jquery.min.js"></script>
    <script src="bootstrap/js/bootstrap.min.js"></script>
    <script src="sidebar/sidebar.js"></script>
    <script src="syntax-highlight/syntax.js"></script>

</body>
</html>